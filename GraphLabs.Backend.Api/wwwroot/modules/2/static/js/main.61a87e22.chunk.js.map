{"version":3,"sources":["Tree.js","TaskGraph.js","FalseTree.js","TreeBuilder.js","App.js","serviceWorker.js","index.js"],"names":["Tree","_React$Component","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","apply","arguments","inherits","createClass","key","value","react_default","a","createElement","width","height","Tree_Node","props","tree","id","depth","onClick","shownChange","active","shown","vertexErrors","weigthErrors","beginPoint","widthArea","vertexAmount","React","Component","Node","_this","children","length","map","e","i","x1","orderInLevel","getAmountInLevel","y1","x2","y2","style","stroke","strokeWidth","childrenOrder","verticesChildren","cx","cy","r","fillOpacity","fill","includes","onMouseEnter","onMouseLeave","x","y","dy","textAnchor","name","dx","weight","join","TaskGraph","_Graph","store","require","taskGraph","Graph","createEmpty","getState","graph","vertices","forEach","addVertex","Vertex","edges","addEdge","Edge","filter","v2","vertexTwo","v1","vertexOne","vertex","reduce","accum","next","concat","neighbours","getNeighbours","push","subVertices","subGraph","v","toString","FalseTree","allElements","find","parentId","level","b","indexOf","Error","get","_this2","_this3","_this4","BorderedDiv","styled","div","_templateObject","GraphCell","extend","_templateObject2","ToolCell","_templateObject3","TaskCell","_templateObject4","LeftBottom","_templateObject5","_templateObject6","LowRow","_templateObject7","App2","_templateObject8","MainRow","_templateObject9","App","console","log","success","res","fee","Task","task","Toolbar","getTaskToolbar","state","status","GraphVisualizer","StudentMark","TaskConsole","TaskTemplate","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.61a87e22.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nexport class Tree extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <svg width={\"100%\"} height={\"480px\"}>\r\n                <Node\r\n                    key={this.props.tree.id}\r\n                    tree={this.props.tree}\r\n                    depth={0}\r\n                    onClick={this.props.onClick}\r\n                    shownChange={this.props.shownChange}\r\n                    active={this.props.active}\r\n                    shown={this.props.shown}\r\n                    vertexErrors={this.props.vertexErrors}\r\n                    weigthErrors={this.props.weigthErrors}\r\n                    beginPoint={0}\r\n                    widthArea={100}\r\n                    vertexAmount={1}\r\n                />\r\n            </svg>\r\n        )\r\n    }\r\n}\r\n\r\nclass Node extends React.Component {\r\n\r\n    render() {\r\n        return (\r\n            <g>\r\n                {this.props.tree.children.length > 0 ? this.props.tree.children.map((e, i) =>\r\n                    <g key={'line'+e.id}>\r\n                        <line\r\n                            x1 = {(this.props.tree.orderInLevel(this.props.tree.id) + 0.5)*100/(this.props.tree.getAmountInLevel(this.props.tree.id)) + \"%\"}\r\n                            y1 = {5 + this.props.depth*10 + \"%\"}\r\n                            x2 = {(this.props.tree.orderInLevel(e.id) + 0.5)*100/this.props.tree.getAmountInLevel(e.id) + \"%\"}\r\n                            y2 = {5 + (this.props.depth + 1)*10 + \"%\"}\r\n                            style = {{stroke: 'black', strokeWidth: \"2px\"}}\r\n                        />\r\n                        <Node\r\n                            key={e.id}\r\n                            tree = {e}\r\n                            depth = {this.props.depth + 1}\r\n                            vertexErrors={this.props.vertexErrors}\r\n                            weigthErrors={this.props.weigthErrors}\r\n                            onClick={this.props.onClick}\r\n                            shownChange={this.props.shownChange}\r\n                            active={this.props.active}\r\n                            shown={this.props.shown}\r\n                            beginPoint={this.props.widthArea*this.props.tree.childrenOrder(this.props.tree.id)}\r\n                            widthArea={100/(this.props.widthArea + 1)}\r\n                            vertexAmount={this.props.tree.verticesChildren(e.id).length}\r\n                        />\r\n                    </g>) : null\r\n                }\r\n                <circle\r\n                    cx = {(this.props.tree.orderInLevel(this.props.tree.id) + 0.5)*100/(this.props.tree.getAmountInLevel(this.props.tree.id)) + \"%\"}\r\n                    cy = {5 + this.props.depth*10 + \"%\"}\r\n                    r = {12}\r\n                    style = {{fillOpacity: 100, stroke: 'black',\r\n                        fill: (this.props.active == this.props.tree.id) ?\r\n                            ((this.props.vertexErrors.includes(this.props.tree.id)) ? \"#E15C7B\" : \"#8CCD9B\") :\r\n                            ((this.props.vertexErrors.includes(this.props.tree.id)) ? \"#EE8DA4\" : \"#EEEEEE\"),\r\n                        strokeWidth: \"2px\"}}\r\n                    onClick = {() => {this.props.onClick(this.props.tree.id)}}\r\n                    onMouseEnter={() => {this.props.shownChange(this.props.tree.id)}}\r\n                    onMouseLeave={() => {this.props.shownChange(null)}}\r\n                />\r\n                <text\r\n                    x = {(this.props.tree.orderInLevel(this.props.tree.id) + 0.5)*100/(this.props.tree.getAmountInLevel(this.props.tree.id)) + \"%\"}\r\n                    y = {5 + this.props.depth*10 + \"%\"}\r\n                    dy = {5 + \"px\"}\r\n                    style = {{textAnchor: \"middle\"}}\r\n                    onClick = {() => {this.props.onClick(this.props.tree.id)}}\r\n                    onMouseEnter={() => {this.props.shownChange(this.props.tree.id)}}\r\n                    onMouseLeave={() => {this.props.shownChange(null)}}\r\n                >\r\n                    {this.props.tree.name}\r\n                </text>\r\n                <rect\r\n                    x = {(this.props.tree.orderInLevel(this.props.tree.id) + 0.5)*100/(this.props.tree.getAmountInLevel(this.props.tree.id)) + 1 + \"%\"}\r\n                    y = {5 + this.props.depth*10 + 1 + \"%\"}\r\n                    width = {64}\r\n                    height= {34}\r\n                    style = {{fillOpacity: (this.props.shown == this.props.tree.id) ? 100 : 0,\r\n                        stroke: 'black',\r\n                        fill: (this.props.weigthErrors.includes(this.props.tree.id)) ? \"#EE8DA4\" : \"#EEEEEE\",\r\n                        strokeWidth: (this.props.shown == this.props.tree.id) ? \"1px\" : \"0px\"}}\r\n                />\r\n                <text\r\n                    x = {(this.props.tree.orderInLevel(this.props.tree.id) + 0.5)*100/(this.props.tree.getAmountInLevel(this.props.tree.id)) + 1 + \"%\"}\r\n                    y = {5 + this.props.depth*10 + 1 + \"%\"}\r\n                    dy = {17 + \"px\"}\r\n                    dx = {32 + \"px\"}\r\n                    style = {{textAnchor: \"middle\", fillOpacity: (this.props.shown == this.props.tree.id) ? 100 : 0}}\r\n                >\r\n                    {this.props.tree.weight.join(\", \")}\r\n                </text>\r\n            </g>\r\n        )\r\n    }\r\n}","import {Graph, Vertex, Edge} from \"graphlabs.core.graphs\"\r\n\r\nexport class TaskGraph extends Graph{\r\n\r\n    static createGraph() {\r\n        let store = require('graphlabs.core.template').store;\r\n        let taskGraph = Graph.createEmpty(0);\r\n        store.getState().graph.vertices.forEach(e => taskGraph.addVertex(new Vertex(e.name)))\r\n        store.getState().graph.edges.forEach(e => taskGraph\r\n            .addEdge(new Edge(taskGraph.vertices.filter(v2 => v2.name == e.vertexTwo),\r\n                taskGraph.vertices.filter(v1 => v1.name == e.vertexOne))))\r\n        return taskGraph\r\n    }\r\n\r\n    static getNeighbours(vertex, graph) {\r\n        return graph.edges.reduce((accum, next) => (next.vertexOne == vertex) ?\r\n            accum.concat(next.vertexTwo) : (next.vertexTwo == vertex) ?\r\n                accum.concat(next.vertexOne) : accum, []).map(e => e.name)\r\n    }\r\n\r\n    static getNonNeighbours(vertex, graph) {\r\n        let neighbours = TaskGraph.getNeighbours(vertex, graph)\r\n        neighbours.push(vertex.name)\r\n        return graph.vertices.reduce((accum, next) => (neighbours.includes(next.name)) ?\r\n            accum : accum.concat(next.name), [])\r\n    }\r\n\r\n    static getSubgraph(subVertices, graph) {\r\n        let subGraph = Graph.createEmpty(0)\r\n        graph.vertices.filter(v => subVertices.includes(v.name)).forEach(v => subGraph.addVertex(v))\r\n        graph.edges.filter(e => subVertices.includes(e.vertexOne.toString())\r\n            && subVertices.includes(e.vertexTwo.toString()))\r\n            .forEach(e => subGraph.addEdge(e))\r\n        return subGraph\r\n    }\r\n}","export class FalseTree {\r\n\r\n    allElements\r\n\r\n    id\r\n    constructor(allElements, id) {\r\n        this.allElements = allElements;\r\n        this.id = id;\r\n    }\r\n\r\n    find(id) {\r\n        return this.allElements.find(e => e.id == id);\r\n    }\r\n\r\n    get name() {\r\n        return this.allElements.find(e => e.id == this.id).name\r\n    }\r\n\r\n    get weight() {\r\n        return this.allElements.find(e => e.id == this.id).weight\r\n    }\r\n\r\n    get parentId() {\r\n        return this.allElements.find(e => e.id == this.id).parentId\r\n    }\r\n\r\n    verticesChildren(id) {\r\n        return this.allElements.filter(e => e.parentId == id)\r\n    }\r\n\r\n    get children() {\r\n        return this.allElements\r\n            .filter(e => e.parentId == this.id)\r\n            .map(e => new FalseTree(this.allElements, e.id))\r\n    }\r\n\r\n    childrenOrder(id) {\r\n        return this.verticesChildren(this.parentId).filter(e => e.id <= id).length\r\n    }\r\n\r\n    orderInLevel(id) {\r\n        let level = [new FalseTree(this.allElements, 0)]\r\n        while (level.find(e => e.id == id) == null) {\r\n            level = level.map(e => e.children).reduce((a,b) => a.concat(b), [])\r\n        }\r\n        return level.indexOf(level.find(e => e.id == id))\r\n    }\r\n\r\n    getAmountInLevel(id) {\r\n        let level = [new FalseTree(this.allElements, 0)]\r\n        while (level.find(e => e.id == id) == null) {\r\n            level = level.map(e => e.children).reduce((a,b) => a.concat(b), [])\r\n        }\r\n        return level.length\r\n    }\r\n\r\n    remove(id) {\r\n        if (this.id == id) throw new Error('Ай-ай-ай! Не удаляй корень, а)');\r\n        this.allElements = this.allElements.reduce((a,e) => (e.id == id) ? a : a.concat(e), [])\r\n    }\r\n}","import React from 'react';\r\nimport {Tree} from './Tree'\r\nimport {TaskGraph} from './TaskGraph'\r\nimport {StudentMark} from 'graphlabs.core.template'\r\nimport {FalseTree} from \"./FalseTree\";\r\n\r\nexport class TreeBuilder extends React.Component {\r\n\r\n    state = {\r\n        tree: undefined,\r\n        active: undefined,\r\n        shown: undefined,\r\n        maxId: 0,\r\n        vertexErrors: [],\r\n        weigthErrors: []\r\n    }\r\n\r\n    onNodeClick = function (id) {\r\n        this.setState({active: id})\r\n        this.newActive(id)\r\n    }\r\n\r\n    newTree = function (newT) {\r\n        this.setState({tree: newT})\r\n    }\r\n\r\n    newActive = function (newA) {\r\n        this.setState({active: newA})\r\n    }\r\n\r\n    newShown = function (newS) {\r\n        this.setState({shown: newS})\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        let graph = TaskGraph.createGraph()\r\n        this.state.tree = new FalseTree([\r\n            {\r\n                id: 0,\r\n                // имя вершины\r\n                name: \"G\",\r\n                // идентификатор родителя\r\n                parentId: undefined,\r\n                // ошибка в вершине\r\n                graph: graph,\r\n                // вес: окрестность вершины\r\n                weight: graph.vertices,\r\n                // идентификатор первой добавленной вершины в уровне\r\n                firstChoosen: false\r\n            }\r\n        ], 0)\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div>\r\n                    <Tree tree={this.state.tree}\r\n                          active={this.state.active}\r\n                          shown={this.state.shown}\r\n                          vertexErrors={this.state.vertexErrors}\r\n                          weigthErrors={this.state.weigthErrors}\r\n                          onClick={this.onNodeClick.bind(this)}\r\n                          treeChange={this.newTree.bind(this)}\r\n                          activeChange={this.newActive.bind(this)}\r\n                          shownChange={this.newShown.bind(this)}\r\n                    ></Tree>\r\n                </div>\r\n                <div style={{position: \"absolute\", top: \"calc(100% - 40px)\", left: \"calc(50% - 35px)\"}}>\r\n                    <button className=\"btn\" style={{height: \"35px\", width: \"35px\"}}\r\n                            onClick={this.addVertexButton.bind(this)}>&#43;</button>\r\n                    <button className=\"btn\" style={{height: \"35px\", width: \"35px\"}}\r\n                            onClick={this.removeVertexButton.bind(this)}>&#8722;</button>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    addVertexButton() {\r\n        if (this.state.active == undefined) {\r\n            alert(\"Выберите вершину дерева, для которой надо добавить потомка\")\r\n        }\r\n        else {\r\n            let vertexName = prompt(\"Введите имя новой вершины\")\r\n            let first = false\r\n            let parentVertex = this.state.tree.find(this.state.active)\r\n            let children = this.state.tree.verticesChildren(parentVertex.id)\r\n            // проверяем, что добавляемая вершина существует в исходном графе\r\n            if (parentVertex.graph.vertices.map(e => e.name).includes(vertexName)) {\r\n                // проверяем, что добавляемая вершина входит в граф, соответствующий вершине-родителю\r\n                // если нет, то записываем ошибку\r\n                if (!parentVertex.graph.vertices.map(e => e.name).includes(vertexName)) {\r\n                    this.state.vertexErrors.push(this.state.maxId + 1)\r\n                }\r\n                // если вершина входит в соответствующий граф, то осуществляем последующие проверки\r\n                else {\r\n                    // если добавляемая вершина не первая в уровне, то проводим последующие проверки\r\n                    if (children.length != 0) {\r\n                        // проверяем, что добавляемая вершина еще не была добавлена в уровень дерева\r\n                        // если была, то записываем ошибку\r\n                        if (children.map(e => e.name).includes(vertexName)) {\r\n                            this.state.vertexErrors.push(this.state.maxId + 1)\r\n                        }\r\n                        //если предыдущая проверка пройдена,то\r\n                        // проверяем, что добавляемая вершина входит в окрестность первой вершины в уровне\r\n                        else {\r\n                            // если не входит, то записываем ошибку\r\n                            if (!(TaskGraph.getNeighbours(children.filter(e => e.firstChoosen)[0].name, parentVertex.graph)\r\n                                .includes(vertexName))) {\r\n                                this.state.vertexErrors.push(this.state.maxId + 1)\r\n                            }\r\n                        }\r\n                    }\r\n                    // если добавляемая вершиная первая в уровне, то необходимо соответственно отметить ее\r\n                    else {\r\n                        first = true\r\n                    }\r\n                }\r\n                // после всех проверок получаем множество вершин, являющихся окрестностью введенной вершины\r\n                let vertexArray = prompt(\"Введите множество вершин (числа через пробел\")\r\n                // проверяем введенную сроку на соответствующий формат\r\n                if (/^[0-9]+(\\s+[0-9]+)*$/.test(vertexArray)) {\r\n                    let vertices = vertexArray.split(/\\s+/)\r\n                    // проверяем, что введенное множество вершин соответствует рассчитанной неокрестности вершины\r\n                    // если несоответствие, то записываем ошибку\r\n                    if (TaskGraph.getNonNeighbours(vertexName, parentVertex.graph)\r\n                        .sort().toString() != vertices.sort().toString()) {\r\n                        this.state.weigthErrors.push(this.state.maxId + 1)\r\n                    }\r\n                    // определяем подграф, соответственно с введенным ранее множеством вершин\r\n                    let subGraph = TaskGraph.getSubgraph(vertices, parentVertex.graph)\r\n                    // создаем новый узел дерева\r\n                    let tempTree = new FalseTree([])\r\n                    tempTree.id = this.state.tree.id\r\n                    tempTree.allElements = this.state.tree.allElements\r\n                    tempTree.allElements.push({\r\n                        id: this.state.maxId + 1,\r\n                        name: vertexName, parentId: this.state.active, weight: vertices,\r\n                        graph: subGraph, firstChoosen: first\r\n                    })\r\n                    this.newTree(tempTree)\r\n                    this.setState({maxId: this.state.maxId + 1})\r\n                }\r\n                else {\r\n                    // если нет, не позволяем добавить вершину\r\n                    alert(\"Пожалуйста, укажите множество вершин через пробел\")\r\n                }\r\n            }\r\n            // если нет, не позволяем добавить вершину\r\n            else {\r\n                alert(\"Невозможно добавить вершину с таким именем. Пожалуйста, перепроверьте вводимое значение.\")\r\n            }\r\n        }\r\n    }\r\n\r\n    removeVertexButton() {\r\n        if (this.state.active.isUndefined) {\r\n            alert(\"Выберите вершину дерева, которую необходимо удалить\")\r\n        }\r\n        else {\r\n            //let conf = alert((confirm(\"wewe\"))\r\n            //let conf = alert(confirm(\"Вы действительно хотите удалить вершину \" + this.state.tree.find(this.state.active).name) + \"?\")\r\n            if (window.confirm(\"Вы действительно хотите удалить вершину \" + this.state.tree.find(this.state.active).name) + \"?\"){\r\n                let verticeToRemove = [this.state.tree.find(this.state.active)]\r\n                let tempTree = new FalseTree([])\r\n                tempTree.id = this.state.tree.id;\r\n                tempTree.allElements = this.state.tree.allElements\r\n                while(verticeToRemove.length != 0) {\r\n                    tempTree.remove(verticeToRemove[0].id)\r\n                    let children = (new FalseTree(this.state.tree.allElements, verticeToRemove[0].id)).children\r\n                    children.forEach(function(e) {\r\n                        verticeToRemove.push(e)\r\n                    })\r\n                    verticeToRemove = verticeToRemove.slice(1)\r\n                }\r\n                this.newTree(tempTree)\r\n                this.state.active = undefined\r\n                this.state.vertexErrors.filter(e => e.id != tempTree.id)\r\n                this.state.weigthErrors.filter(e => e.id != tempTree.id)\r\n            }\r\n        }\r\n    }\r\n}","import React, { Component } from 'react';\nimport {default as styled, StyledFunction } from 'styled-components';\nimport {StudentMark} from 'graphlabs.core.template/build/components/StudentMark/StudentMark';\nimport {TaskConsole} from 'graphlabs.core.template/build/components/TaskConsole/TaskConsole';\nimport {GraphVisualizer} from 'graphlabs.core.template/build/components/GraphVisualizer/GraphVisualizer';\nimport { TaskTemplate } from 'graphlabs.core.template';\nimport {TreeBuilder} from './TreeBuilder';\n// import logo from './logo.svg';\n// import { CommonGraphAdapter } from \"graphlabs.core.template\"\n// import {IGraph, IVertex, IEdge } from \"graphlabs.core.graphs\";\n// import {actionsCreators} from \"graphlabs.core.template\";\n\nimport './App.css';\n\nconst BorderedDiv = styled.div`\n  {\n    box-shadow:2px 2px 11px rgba(0, 0, 0, 0.5);\n    -webkit-box-shadow:2px 2px 11px rgba(0, 0, 0, 0.5);\n    border-radius: 10px;\n    background: #fffaf0;\n  }\n`;\n\nconst GraphCell = BorderedDiv.extend`\n  {\n    position: fixed;\n    left: 15%;\n    top: 1%;\n    width: 62%;\n    height: 78%;\n  }\n`;\n\nconst ToolCell = BorderedDiv.extend`\n  {\n     position: fixed;\n    left: 1%;\n    top: 1%;\n    width: 12%;\n    height: 78%;\n  }\n`;\n\nconst TaskCell = BorderedDiv.extend`\n  {\n    position: fixed;\n    left: 79%;\n    top: 1%;\n    width: 20%;\n    height: 78%;\n  }\n`;\n\nconst TaskCell2 = BorderedDiv.extend`\n  {\n    position: fixed;\n    left: 79%;\n    top: 17%;\n    width: 20%;\n    height: 62%;\n  }\n`;\n\nconst LeftBottom = BorderedDiv.extend`\n  {\n    position: fixed;\n    left: 1%;\n    top: 80%;\n    width: 12%;\n    height: 19%;\n  }\n`;\n\nconst LowRow =  BorderedDiv.extend`\n  {\n    position: fixed;\n    left: 15%;\n    top: 80%;\n    width: 84%;\n    height: 19%;\n  }\n`;\n\nconst App2 = styled.div`\n  {\n    position: fixed;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n  }\n`;\n\nconst MainRow = styled.div`\n  {\n    position: fixed;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 80%;\n  }\n`;\n\n// noinspection JSAnnotator\nclass App extends TaskTemplate {\n\n    /*// граф и его характеристики\n    // граф\n    graph;\n\n    // минимальное число вершин, которые покрывают все ребра графа\n    minVertexCovering;\n\n    // минимальное число ребер, которые покрывают все вершины графа\n    minEdgeCovering;\n\n    // массив вершинных покрытий\n    vertexCoverings;\n\n    // массив реберных покрытий\n    edgeCoverings;\n\n    // матрицасмежности вершин\n    vertexAdMatrix;\n\n    // матрица смежности ребер\n    edgeAdMatrix;\n\n    // дополненная матрица смежности вершин\n    completeVertexAdMatrix;\n\n    // дополненная матрица смежности ребер\n    completeEdgeAdMatrix;\n\n    // массив множеств несмежных вершин\n    noncontVertices;\n\n    // массив множеств несмежных ребер\n    noncontEdges;\n\n    // наибольшее число несмежных вершин\n    maxNoncontVertices;\n\n    // наибольшее число несмежных ребер\n    maxNoncontEdges;\n\n    // проверка ответов пользователя\n    // проверка минимального числа вершин, покрывающих все ребра графа\n\n\n    // проверка минимального числа ребер, покрывающих все вершины графа\n\n\n    // проверка массива вершинных покрытий\n\n\n    // проверка массива реберных покрытий\n\n\n    // проверка матрицы смежности вершин\n\n\n    // проверка матрицы смежности ребер\n\n\n    // проверка дополненной матрицы смежности вершин\n\n\n    // проверка дополненной матрицы смежности ребер\n\n\n    // проверка массива множеств несмежных вершин\n\n\n    // проверка массива множеств несмежных ребер\n\n\n    // проверка наибольшего числа несмежных вершин\n\n\n    // проверка наибольшего числа несмежных ребер\n\n    // методы для определения характеристик графа\n    // определение минимального числа вершин, которые покрывают все ребра графа\n    defMinVertexCovering() {\n\n    };\n\n    // определение минимального числа ребер, которые покрывают все вершины графа\n    defMinEdgeCovering() {\n\n    };\n\n    // определение массива вершинных покрытий\n    defVertexCoverings() {\n\n    };\n\n    // определение массива реберных покрытий\n    defEdgeCoverings() {\n\n    };\n\n    // определение матрицы смежности вершин\n    defVertexAdMatrix() {\n\n    };\n\n    // определение матрицы смежности ребер\n    defEdgeAdMatrix() {\n\n    };\n\n    // определение дополненной матрицы смежности вершин\n    defCompleteVertexAdMatrix() {\n        for (let i = 0; i < vertexMatrix.length; i++) {\n            for (let j = 0; j < vertexMatrixMatrix.length; j++) {\n                if (i == j) {\n                    vertexMatrix[i][j] = 1;\n                }\n            }\n        }\n    };\n\n    // определение дополненной матрицы смежности ребер\n    defCompleteEdgeAdMatrix() {\n        for (let i = 0; i < edgeMatrix.length; i++) {\n            for (let j = 0; j < edgeMatrix.length; j++) {\n                if (i == j) {\n                    edgeMatrix[i][j] = 1;\n                }\n            }\n        }\n    };\n\n    // определение массива множеств несмежных вершин\n    defNoncontVertices() {\n\n    };\n\n    // определение массива множеств несмежных ребер\n    defNoncontEdges() {\n\n    };\n\n    // определение наибольшего числа несмежных вершин\n    defMaxNoncontVertices() {\n\n    };\n\n    // определение наибольшего числа несмежных ребер\n    defMaxNoncontEdges() {\n\n    };\n*/\n    calculate() {\n        let res = 10;\n        console.log(res);\n        return { success: res === 0, fee: res };\n    }\n\n    render() {\n        let Task = this.task();\n        const Toolbar = this.getTaskToolbar();\n        return (\n            <App2 id=\"wrap\">\n                {this.state.status ?\n                    <p>Задание выполнено. Ожидайте ответа от сервера...</p>\n                    :\n                    (\n                        <div>\n                            <MainRow>\n                                <GraphCell>\n                                    <GraphVisualizer/>\n                                </GraphCell>\n                                <TaskCell>\n                                    <p>Задание</p>\n                                    <Task/>\n\n\n\n                                </TaskCell>\n                                <ToolCell>\n                                    <Toolbar/>\n                                </ToolCell>\n                            </MainRow>\n                            <LeftBottom>\n                                <StudentMark/>\n                            </LeftBottom>\n                            <LowRow>\n                                <TaskConsole/>\n                            </LowRow>\n                        </div>\n                    )\n                }\n        </App2>\n        )\n    }\n\n    /*getTaskToolbar() {\n        TaskToolbar.prototype.getButtonList = () => {\n            function beforeComplete() {\n                return new Promise((resolve => {\n                    resolve(this.calculate());\n                }));\n            }\n            ToolButtonList.prototype.beforeComplete = beforeComplete.bind(this);\n            ToolButtonList.prototype.help = () => `В данном задании вы должны заполнить матрицу смежности\nв правой части модуля согласно выданному графу.\nПосле заполнения матрицы нажмите кнопку отправки для проверки задания`;\n            return ToolButtonList;\n        };\n        return TaskToolbar;\n    }*/\n    /*task() {\n        const graph = store.getState().graph;\n        return () => (\n            <Matrix\n                rows={graph.vertices.length}\n                columns={graph.vertices.length}\n                handler={this.handler}\n            />);\n    }*/\n}\n\nexport default App;\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}